!function(c,n){"object"==typeof exports&&"object"==typeof module?module.exports=n(require("react")):"function"==typeof define&&define.amd?define(["react"],n):"object"==typeof exports?exports.UniversalSearch=n(require("react")):c.UniversalSearch=n(c.react)}(this,function(__WEBPACK_EXTERNAL_MODULE_1__){return function(c){function n(I){if(t[I])return t[I].exports;var g=t[I]={i:I,l:!1,exports:{}};return c[I].call(g.exports,g,g.exports,n),g.l=!0,g.exports}var t={};return n.m=c,n.c=t,n.d=function(c,t,I){n.o(c,t)||Object.defineProperty(c,t,{configurable:!1,enumerable:!0,get:I})},n.n=function(c){var t=c&&c.__esModule?function(){return c.default}:function(){return c};return n.d(t,"a",t),t},n.o=function(c,n){return Object.prototype.hasOwnProperty.call(c,n)},n.p="",n(n.s=0)}([function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _react = __webpack_require__(1);\n\nvar _react2 = _interopRequireDefault(_react);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar formattingErr = ' Cannot parse object. Please make sure you\\'re passing in \"listToSearch\" in one of the following formats:\\n\\nPlain Array of Objects (i.e. No Categories):\\n\\n[\\n  { name: \\'foo\\' },\\n  { name: \\'bar\\' },\\n  { name: \\'baz\\' },\\n  ...\\n]\\n\\n---\\n\\nKeyed Objects Containing Arrays:\\n\\n{\\n  foo: [\\n    {name: \\'bar\\'},\\n    ...\\n  ],\\n  baz: [\\n    {name: \\'qux\\'},\\n    ...\\n  ],\\n  ...\\n}\\n';\n\nvar methodWarning = function methodWarning(passedMethod) {\n  return '\\n  Invalid Method: \"' + passedMethod + '\".\\nFalling back to \"greedy\"\\n\\nValid Options are [\\'greedy\\', \\'strict\\', and \\'symbol-permissive\\' ]. If no method is specified, \"greedy\" will automatically be used without showing this warning.\\n';\n};\n\nvar UniversalSearch = function (_React$Component) {\n  _inherits(UniversalSearch, _React$Component);\n\n  function UniversalSearch(props) {\n    _classCallCheck(this, UniversalSearch);\n\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set\n\n    // this library uses an ES6 Set()\n    // typically, we get O(1) across the board with this data structure\n    var _this = _possibleConstructorReturn(this, (UniversalSearch.__proto__ || Object.getPrototypeOf(UniversalSearch)).call(this, props));\n\n    _this.state = {\n      query: '',\n      results: new Set(),\n      focused: !_this.props.focusedOnly\n    };\n\n    _this.checkForCategories = _this.checkForCategories.bind(_this);\n    _this.inputQuery = _this.inputQuery.bind(_this);\n    _this.filterMatches = _this.filterMatches.bind(_this);\n    _this.renderMatches = _this.renderMatches.bind(_this);\n    _this.renderMatchCount = _this.renderMatchCount.bind(_this);\n    _this.renderIfNoMatches = _this.renderIfNoMatches.bind(_this);\n    _this.focusHandler = _this.focusHandler.bind(_this);\n    return _this;\n  }\n\n  _createClass(UniversalSearch, [{\n    key: 'componentWillMount',\n    value: function componentWillMount() {\n      // check if categories were explicitly passed\n      // if not, iterate through the Object keys\n      // and see if category inclusion can be detected from structure\n      this.includeCategories = typeof this.props.hasCategories !== 'undefined' ? this.props.hasCategories : this.checkForCategories(this.props.listToSearch);\n    }\n  }, {\n    key: 'componentDidMount',\n    value: function componentDidMount() {\n      var validParseMethods = ['greedy', 'strict', 'symbol-permissive'];\n      if (this.props.parseMethod && !validParseMethods.includes(this.props.parseMethod)) {\n        console.warn(methodWarning(this.props.parseMethod));\n      }\n\n      if (_typeof(this.props.listToSearch) !== 'object') {\n        console.error(formattingErr);\n      }\n    }\n  }, {\n    key: 'checkForCategories',\n    value: function checkForCategories(listToSearch) {\n      var listKeys = Object.keys(listToSearch);\n      for (var i = 0; i < listKeys.length; i++) {\n        if (Array.isArray(listToSearch[listKeys[i]])) {\n          // short-circuit if following the Object --\x3e Array structure\n          return true;\n        }\n      }\n      // if not, assume regular array\n      return false;\n    }\n  }, {\n    key: 'inputQuery',\n    value: function inputQuery(e) {\n      // escape input and build RE query\n      var input = e.target.value.replace(/[\\.\\+\\*\\?\\^\\$\\[\\]\\{\\}\\(\\)\\|\\/\\\\]/ig, function (sym) {\n        return '\\\\' + sym;\n      });\n      var re = void 0;\n\n      if (this.props.parseMethod === 'strict') {\n        re = input.trim().length > 0 ? new RegExp('^' + input.trim(), 'gi') : '';\n      } else if (this.props.parseMethod === 'symbol-permissive') {\n        re = input.trim().length > 0 ? new RegExp('^([\\\\W\\\\s]+?' + input.trim() + '(\\\\w+)?[\\\\W\\\\s]+?)|^([\\\\W\\\\s]?(\\\\w+)?[\\\\W\\\\s]+)?' + input.trim(), 'ig') : '';\n      } else {\n        re = input.trim().length > 0 ? new RegExp(input.trim(), 'gi') : '';\n      }\n\n      this.setState({\n        query: input\n      });\n\n      if (input) {\n        // use our RE matches to filter on matching strings\n        this.filterMatches(re);\n      } else {\n        // clear all results if search string is empty\n        this.state.results.clear();\n      }\n    }\n  }, {\n    key: 'filterMatches',\n    value: function filterMatches(re) {\n      var _this2 = this;\n\n      var scan = function scan(inputArr, category) {\n        var hasHeader = false;\n        // only applicable if result limit specified\n        var showing = 0;\n        for (var i = 0; i < inputArr.length; i++) {\n          var item = inputArr[i];\n          item._firstInCategory = false;\n          if (item.name.match(re) && re !== '') {\n            // if string matches\n            showing++;\n\n            // delete the item if it exists to re-init order\n            _this2.state.results.delete(item);\n\n            item._category = category;\n            if (!hasHeader) {\n              item._firstInCategory = true;\n              hasHeader = true;\n            }\n            // if a limit was passed in, check if we've exceeded it\n            // if so, bail out\n            if (!_this2.props.limitResults || showing <= _this2.props.limitResults) {\n              _this2.state.results.add(item);\n            }\n          } else {\n            // if string does not match,\n            // strip order-based props\n            if (item._firstInCategory) {\n              item._firstInCategory = false;\n              // this category no longer has a header...\n              // it will be set in the next item\n              hasHeader = false;\n            }\n            _this2.state.results.delete(item);\n          }\n        }\n      };\n\n      if (this.includeCategories) {\n        // if there are categories, iterate through the contents of each one separately\n        Object.keys(this.props.listToSearch).forEach(function (category) {\n          scan(_this2.props.listToSearch[category], category);\n        });\n      } else {\n        // otherwise, simply iterate through a single array\n        scan(this.props.listToSearch);\n      }\n    }\n  }, {\n    key: 'renderMatches',\n    value: function renderMatches(resultsSet) {\n      var _this3 = this;\n\n      // we use a Spread Operator to temporarily transform a Set into an Array\n      // this makes it easier to map into React\n      return [].concat(_toConsumableArray(resultsSet)).map(function (matchingEntry, i) {\n        if (_this3.props.customComponent) {\n          return _this3.props.customComponent(matchingEntry, i);\n        }\n        // default structure if not specified\n        var entry = _react2.default.createElement(\n          'div',\n          {\n            className: 'univ-search-matching-results ' + (matchingEntry._firstInCategory ? 'univ-search-category-head' : ''),\n            key: 'match_' + i\n          },\n          _this3.includeCategories && matchingEntry._firstInCategory ? _react2.default.createElement(\n            'div',\n            {\n              className: 'univ-search-category-head',\n              style: { color: '#aaa', fontStyle: 'italic', fontSize: '12px', margin: '10px 0' }\n            },\n            matchingEntry._category\n          ) : null,\n          matchingEntry.name\n        );\n        return entry;\n      });\n    }\n  }, {\n    key: 'renderMatchCount',\n    value: function renderMatchCount(matchCount) {\n      // optional\n      return this.props.customMatchCountComponent ? this.props.customMatchCountComponent(matchCount) : _react2.default.createElement(\n        'div',\n        { className: 'univ-search-match-count', style: { marginTop: '10px', color: '#aaa' } },\n        matchCount,\n        ' Matches'\n      );\n    }\n  }, {\n    key: 'renderIfNoMatches',\n    value: function renderIfNoMatches(query) {\n      // also optional\n\n      // do not show \"no matches found\" message if no query\n      // may change this to an option later\n      if (!query) {\n        return null;\n      }\n      return this.props.customNoMatchComponent ? this.props.customNoMatchComponent : _react2.default.createElement(\n        'div',\n        { className: 'univ-search-no-matches' },\n        'No Matches...'\n      );\n    }\n  }, {\n    key: 'focusHandler',\n    value: function focusHandler() {\n      if (this.props.focusedOnly) {\n        this.setState({\n          focused: !this.state.focused\n        });\n      }\n    }\n  }, {\n    key: 'render',\n    value: function render() {\n      var matchesFound = this.state.results.size > 0;\n\n      var matchCountComponent = this.props.showMatchCount || this.props.customMatchCountComponent ? this.renderMatchCount(this.state.results.size) : null;\n      var noMatchComponent = this.props.showWhenNoMatches || this.props.customNoMatchComponent ? this.renderIfNoMatches(this.state.query) : null;\n\n      var matchingItemElements = matchesFound ? this.renderMatches(this.state.results) : noMatchComponent;\n\n      var showResults = this.state.query && !this.state.query.match(/^\\s+$/igm) && this.state.focused;\n\n      return _react2.default.createElement(\n        'div',\n        { className: 'univ-search-wrapper' },\n        _react2.default.createElement('input', {\n          placeholder: this.props.placeholder,\n          onChange: this.inputQuery,\n          onFocus: this.focusHandler,\n          onBlur: this.focusHandler\n        }),\n        matchCountComponent,\n        _react2.default.createElement('br', null),\n        _react2.default.createElement('br', null),\n        _react2.default.createElement(\n          'div',\n          {\n            className: 'univ-search-results-wrapper',\n            style: { display: showResults ? 'inherit' : 'none' }\n          },\n          matchingItemElements\n        )\n      );\n    }\n  }]);\n\n  return UniversalSearch;\n}(_react2.default.Component);\n\nexports.default = UniversalSearch;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9Vbml2ZXJzYWxTZWFyY2guanM/MzM3ZSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBBcnJheShhcnIubGVuZ3RoKTsgaSA8IGFyci5sZW5ndGg7IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9IGVsc2UgeyByZXR1cm4gQXJyYXkuZnJvbShhcnIpOyB9IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgZm9ybWF0dGluZ0VyciA9ICcgQ2Fubm90IHBhcnNlIG9iamVjdC4gUGxlYXNlIG1ha2Ugc3VyZSB5b3VcXCdyZSBwYXNzaW5nIGluIFwibGlzdFRvU2VhcmNoXCIgaW4gb25lIG9mIHRoZSBmb2xsb3dpbmcgZm9ybWF0czpcXG5cXG5QbGFpbiBBcnJheSBvZiBPYmplY3RzIChpLmUuIE5vIENhdGVnb3JpZXMpOlxcblxcbltcXG4gIHsgbmFtZTogXFwnZm9vXFwnIH0sXFxuICB7IG5hbWU6IFxcJ2JhclxcJyB9LFxcbiAgeyBuYW1lOiBcXCdiYXpcXCcgfSxcXG4gIC4uLlxcbl1cXG5cXG4tLS1cXG5cXG5LZXllZCBPYmplY3RzIENvbnRhaW5pbmcgQXJyYXlzOlxcblxcbntcXG4gIGZvbzogW1xcbiAgICB7bmFtZTogXFwnYmFyXFwnfSxcXG4gICAgLi4uXFxuICBdLFxcbiAgYmF6OiBbXFxuICAgIHtuYW1lOiBcXCdxdXhcXCd9LFxcbiAgICAuLi5cXG4gIF0sXFxuICAuLi5cXG59XFxuJztcblxudmFyIG1ldGhvZFdhcm5pbmcgPSBmdW5jdGlvbiBtZXRob2RXYXJuaW5nKHBhc3NlZE1ldGhvZCkge1xuICByZXR1cm4gJ1xcbiAgSW52YWxpZCBNZXRob2Q6IFwiJyArIHBhc3NlZE1ldGhvZCArICdcIi5cXG5GYWxsaW5nIGJhY2sgdG8gXCJncmVlZHlcIlxcblxcblZhbGlkIE9wdGlvbnMgYXJlIFtcXCdncmVlZHlcXCcsIFxcJ3N0cmljdFxcJywgYW5kIFxcJ3N5bWJvbC1wZXJtaXNzaXZlXFwnIF0uIElmIG5vIG1ldGhvZCBpcyBzcGVjaWZpZWQsIFwiZ3JlZWR5XCIgd2lsbCBhdXRvbWF0aWNhbGx5IGJlIHVzZWQgd2l0aG91dCBzaG93aW5nIHRoaXMgd2FybmluZy5cXG4nO1xufTtcblxudmFyIFVuaXZlcnNhbFNlYXJjaCA9IGZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0cyhVbml2ZXJzYWxTZWFyY2gsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIFVuaXZlcnNhbFNlYXJjaChwcm9wcykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBVbml2ZXJzYWxTZWFyY2gpO1xuXG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU2V0XG5cbiAgICAvLyB0aGlzIGxpYnJhcnkgdXNlcyBhbiBFUzYgU2V0KClcbiAgICAvLyB0eXBpY2FsbHksIHdlIGdldCBPKDEpIGFjcm9zcyB0aGUgYm9hcmQgd2l0aCB0aGlzIGRhdGEgc3RydWN0dXJlXG4gICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKFVuaXZlcnNhbFNlYXJjaC5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFVuaXZlcnNhbFNlYXJjaCkpLmNhbGwodGhpcywgcHJvcHMpKTtcblxuICAgIF90aGlzLnN0YXRlID0ge1xuICAgICAgcXVlcnk6ICcnLFxuICAgICAgcmVzdWx0czogbmV3IFNldCgpLFxuICAgICAgZm9jdXNlZDogIV90aGlzLnByb3BzLmZvY3VzZWRPbmx5XG4gICAgfTtcblxuICAgIF90aGlzLmNoZWNrRm9yQ2F0ZWdvcmllcyA9IF90aGlzLmNoZWNrRm9yQ2F0ZWdvcmllcy5iaW5kKF90aGlzKTtcbiAgICBfdGhpcy5pbnB1dFF1ZXJ5ID0gX3RoaXMuaW5wdXRRdWVyeS5iaW5kKF90aGlzKTtcbiAgICBfdGhpcy5maWx0ZXJNYXRjaGVzID0gX3RoaXMuZmlsdGVyTWF0Y2hlcy5iaW5kKF90aGlzKTtcbiAgICBfdGhpcy5yZW5kZXJNYXRjaGVzID0gX3RoaXMucmVuZGVyTWF0Y2hlcy5iaW5kKF90aGlzKTtcbiAgICBfdGhpcy5yZW5kZXJNYXRjaENvdW50ID0gX3RoaXMucmVuZGVyTWF0Y2hDb3VudC5iaW5kKF90aGlzKTtcbiAgICBfdGhpcy5yZW5kZXJJZk5vTWF0Y2hlcyA9IF90aGlzLnJlbmRlcklmTm9NYXRjaGVzLmJpbmQoX3RoaXMpO1xuICAgIF90aGlzLmZvY3VzSGFuZGxlciA9IF90aGlzLmZvY3VzSGFuZGxlci5iaW5kKF90aGlzKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoVW5pdmVyc2FsU2VhcmNoLCBbe1xuICAgIGtleTogJ2NvbXBvbmVudFdpbGxNb3VudCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxNb3VudCgpIHtcbiAgICAgIC8vIGNoZWNrIGlmIGNhdGVnb3JpZXMgd2VyZSBleHBsaWNpdGx5IHBhc3NlZFxuICAgICAgLy8gaWYgbm90LCBpdGVyYXRlIHRocm91Z2ggdGhlIE9iamVjdCBrZXlzXG4gICAgICAvLyBhbmQgc2VlIGlmIGNhdGVnb3J5IGluY2x1c2lvbiBjYW4gYmUgZGV0ZWN0ZWQgZnJvbSBzdHJ1Y3R1cmVcbiAgICAgIHRoaXMuaW5jbHVkZUNhdGVnb3JpZXMgPSB0eXBlb2YgdGhpcy5wcm9wcy5oYXNDYXRlZ29yaWVzICE9PSAndW5kZWZpbmVkJyA/IHRoaXMucHJvcHMuaGFzQ2F0ZWdvcmllcyA6IHRoaXMuY2hlY2tGb3JDYXRlZ29yaWVzKHRoaXMucHJvcHMubGlzdFRvU2VhcmNoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjb21wb25lbnREaWRNb3VudCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgdmFyIHZhbGlkUGFyc2VNZXRob2RzID0gWydncmVlZHknLCAnc3RyaWN0JywgJ3N5bWJvbC1wZXJtaXNzaXZlJ107XG4gICAgICBpZiAodGhpcy5wcm9wcy5wYXJzZU1ldGhvZCAmJiAhdmFsaWRQYXJzZU1ldGhvZHMuaW5jbHVkZXModGhpcy5wcm9wcy5wYXJzZU1ldGhvZCkpIHtcbiAgICAgICAgY29uc29sZS53YXJuKG1ldGhvZFdhcm5pbmcodGhpcy5wcm9wcy5wYXJzZU1ldGhvZCkpO1xuICAgICAgfVxuXG4gICAgICBpZiAoX3R5cGVvZih0aGlzLnByb3BzLmxpc3RUb1NlYXJjaCkgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZm9ybWF0dGluZ0Vycik7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY2hlY2tGb3JDYXRlZ29yaWVzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2hlY2tGb3JDYXRlZ29yaWVzKGxpc3RUb1NlYXJjaCkge1xuICAgICAgdmFyIGxpc3RLZXlzID0gT2JqZWN0LmtleXMobGlzdFRvU2VhcmNoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdEtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobGlzdFRvU2VhcmNoW2xpc3RLZXlzW2ldXSkpIHtcbiAgICAgICAgICAvLyBzaG9ydC1jaXJjdWl0IGlmIGZvbGxvd2luZyB0aGUgT2JqZWN0IC0tPiBBcnJheSBzdHJ1Y3R1cmVcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gaWYgbm90LCBhc3N1bWUgcmVndWxhciBhcnJheVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2lucHV0UXVlcnknLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbnB1dFF1ZXJ5KGUpIHtcbiAgICAgIC8vIGVzY2FwZSBpbnB1dCBhbmQgYnVpbGQgUkUgcXVlcnlcbiAgICAgIHZhciBpbnB1dCA9IGUudGFyZ2V0LnZhbHVlLnJlcGxhY2UoL1tcXC5cXCtcXCpcXD9cXF5cXCRcXFtcXF1cXHtcXH1cXChcXClcXHxcXC9cXFxcXS9pZywgZnVuY3Rpb24gKHN5bSkge1xuICAgICAgICByZXR1cm4gJ1xcXFwnICsgc3ltO1xuICAgICAgfSk7XG4gICAgICB2YXIgcmUgPSB2b2lkIDA7XG5cbiAgICAgIGlmICh0aGlzLnByb3BzLnBhcnNlTWV0aG9kID09PSAnc3RyaWN0Jykge1xuICAgICAgICByZSA9IGlucHV0LnRyaW0oKS5sZW5ndGggPiAwID8gbmV3IFJlZ0V4cCgnXicgKyBpbnB1dC50cmltKCksICdnaScpIDogJyc7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMucHJvcHMucGFyc2VNZXRob2QgPT09ICdzeW1ib2wtcGVybWlzc2l2ZScpIHtcbiAgICAgICAgcmUgPSBpbnB1dC50cmltKCkubGVuZ3RoID4gMCA/IG5ldyBSZWdFeHAoJ14oW1xcXFxXXFxcXHNdKz8nICsgaW5wdXQudHJpbSgpICsgJyhcXFxcdyspP1tcXFxcV1xcXFxzXSs/KXxeKFtcXFxcV1xcXFxzXT8oXFxcXHcrKT9bXFxcXFdcXFxcc10rKT8nICsgaW5wdXQudHJpbSgpLCAnaWcnKSA6ICcnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmUgPSBpbnB1dC50cmltKCkubGVuZ3RoID4gMCA/IG5ldyBSZWdFeHAoaW5wdXQudHJpbSgpLCAnZ2knKSA6ICcnO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgcXVlcnk6IGlucHV0XG4gICAgICB9KTtcblxuICAgICAgaWYgKGlucHV0KSB7XG4gICAgICAgIC8vIHVzZSBvdXIgUkUgbWF0Y2hlcyB0byBmaWx0ZXIgb24gbWF0Y2hpbmcgc3RyaW5nc1xuICAgICAgICB0aGlzLmZpbHRlck1hdGNoZXMocmUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gY2xlYXIgYWxsIHJlc3VsdHMgaWYgc2VhcmNoIHN0cmluZyBpcyBlbXB0eVxuICAgICAgICB0aGlzLnN0YXRlLnJlc3VsdHMuY2xlYXIoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdmaWx0ZXJNYXRjaGVzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmlsdGVyTWF0Y2hlcyhyZSkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHZhciBzY2FuID0gZnVuY3Rpb24gc2NhbihpbnB1dEFyciwgY2F0ZWdvcnkpIHtcbiAgICAgICAgdmFyIGhhc0hlYWRlciA9IGZhbHNlO1xuICAgICAgICAvLyBvbmx5IGFwcGxpY2FibGUgaWYgcmVzdWx0IGxpbWl0IHNwZWNpZmllZFxuICAgICAgICB2YXIgc2hvd2luZyA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5wdXRBcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgaXRlbSA9IGlucHV0QXJyW2ldO1xuICAgICAgICAgIGl0ZW0uX2ZpcnN0SW5DYXRlZ29yeSA9IGZhbHNlO1xuICAgICAgICAgIGlmIChpdGVtLm5hbWUubWF0Y2gocmUpICYmIHJlICE9PSAnJykge1xuICAgICAgICAgICAgLy8gaWYgc3RyaW5nIG1hdGNoZXNcbiAgICAgICAgICAgIHNob3dpbmcrKztcblxuICAgICAgICAgICAgLy8gZGVsZXRlIHRoZSBpdGVtIGlmIGl0IGV4aXN0cyB0byByZS1pbml0IG9yZGVyXG4gICAgICAgICAgICBfdGhpczIuc3RhdGUucmVzdWx0cy5kZWxldGUoaXRlbSk7XG5cbiAgICAgICAgICAgIGl0ZW0uX2NhdGVnb3J5ID0gY2F0ZWdvcnk7XG4gICAgICAgICAgICBpZiAoIWhhc0hlYWRlcikge1xuICAgICAgICAgICAgICBpdGVtLl9maXJzdEluQ2F0ZWdvcnkgPSB0cnVlO1xuICAgICAgICAgICAgICBoYXNIZWFkZXIgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaWYgYSBsaW1pdCB3YXMgcGFzc2VkIGluLCBjaGVjayBpZiB3ZSd2ZSBleGNlZWRlZCBpdFxuICAgICAgICAgICAgLy8gaWYgc28sIGJhaWwgb3V0XG4gICAgICAgICAgICBpZiAoIV90aGlzMi5wcm9wcy5saW1pdFJlc3VsdHMgfHwgc2hvd2luZyA8PSBfdGhpczIucHJvcHMubGltaXRSZXN1bHRzKSB7XG4gICAgICAgICAgICAgIF90aGlzMi5zdGF0ZS5yZXN1bHRzLmFkZChpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gaWYgc3RyaW5nIGRvZXMgbm90IG1hdGNoLFxuICAgICAgICAgICAgLy8gc3RyaXAgb3JkZXItYmFzZWQgcHJvcHNcbiAgICAgICAgICAgIGlmIChpdGVtLl9maXJzdEluQ2F0ZWdvcnkpIHtcbiAgICAgICAgICAgICAgaXRlbS5fZmlyc3RJbkNhdGVnb3J5ID0gZmFsc2U7XG4gICAgICAgICAgICAgIC8vIHRoaXMgY2F0ZWdvcnkgbm8gbG9uZ2VyIGhhcyBhIGhlYWRlci4uLlxuICAgICAgICAgICAgICAvLyBpdCB3aWxsIGJlIHNldCBpbiB0aGUgbmV4dCBpdGVtXG4gICAgICAgICAgICAgIGhhc0hlYWRlciA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMyLnN0YXRlLnJlc3VsdHMuZGVsZXRlKGl0ZW0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgaWYgKHRoaXMuaW5jbHVkZUNhdGVnb3JpZXMpIHtcbiAgICAgICAgLy8gaWYgdGhlcmUgYXJlIGNhdGVnb3JpZXMsIGl0ZXJhdGUgdGhyb3VnaCB0aGUgY29udGVudHMgb2YgZWFjaCBvbmUgc2VwYXJhdGVseVxuICAgICAgICBPYmplY3Qua2V5cyh0aGlzLnByb3BzLmxpc3RUb1NlYXJjaCkuZm9yRWFjaChmdW5jdGlvbiAoY2F0ZWdvcnkpIHtcbiAgICAgICAgICBzY2FuKF90aGlzMi5wcm9wcy5saXN0VG9TZWFyY2hbY2F0ZWdvcnldLCBjYXRlZ29yeSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gb3RoZXJ3aXNlLCBzaW1wbHkgaXRlcmF0ZSB0aHJvdWdoIGEgc2luZ2xlIGFycmF5XG4gICAgICAgIHNjYW4odGhpcy5wcm9wcy5saXN0VG9TZWFyY2gpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3JlbmRlck1hdGNoZXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXJNYXRjaGVzKHJlc3VsdHNTZXQpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICAvLyB3ZSB1c2UgYSBTcHJlYWQgT3BlcmF0b3IgdG8gdGVtcG9yYXJpbHkgdHJhbnNmb3JtIGEgU2V0IGludG8gYW4gQXJyYXlcbiAgICAgIC8vIHRoaXMgbWFrZXMgaXQgZWFzaWVyIHRvIG1hcCBpbnRvIFJlYWN0XG4gICAgICByZXR1cm4gW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShyZXN1bHRzU2V0KSkubWFwKGZ1bmN0aW9uIChtYXRjaGluZ0VudHJ5LCBpKSB7XG4gICAgICAgIGlmIChfdGhpczMucHJvcHMuY3VzdG9tQ29tcG9uZW50KSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzMy5wcm9wcy5jdXN0b21Db21wb25lbnQobWF0Y2hpbmdFbnRyeSwgaSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZGVmYXVsdCBzdHJ1Y3R1cmUgaWYgbm90IHNwZWNpZmllZFxuICAgICAgICB2YXIgZW50cnkgPSBfcmVhY3QyLmRlZmF1bHQuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAnZGl2JyxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjbGFzc05hbWU6ICd1bml2LXNlYXJjaC1tYXRjaGluZy1yZXN1bHRzICcgKyAobWF0Y2hpbmdFbnRyeS5fZmlyc3RJbkNhdGVnb3J5ID8gJ3VuaXYtc2VhcmNoLWNhdGVnb3J5LWhlYWQnIDogJycpLFxuICAgICAgICAgICAga2V5OiAnbWF0Y2hfJyArIGlcbiAgICAgICAgICB9LFxuICAgICAgICAgIF90aGlzMy5pbmNsdWRlQ2F0ZWdvcmllcyAmJiBtYXRjaGluZ0VudHJ5Ll9maXJzdEluQ2F0ZWdvcnkgPyBfcmVhY3QyLmRlZmF1bHQuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICdkaXYnLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBjbGFzc05hbWU6ICd1bml2LXNlYXJjaC1jYXRlZ29yeS1oZWFkJyxcbiAgICAgICAgICAgICAgc3R5bGU6IHsgY29sb3I6ICcjYWFhJywgZm9udFN0eWxlOiAnaXRhbGljJywgZm9udFNpemU6ICcxMnB4JywgbWFyZ2luOiAnMTBweCAwJyB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbWF0Y2hpbmdFbnRyeS5fY2F0ZWdvcnlcbiAgICAgICAgICApIDogbnVsbCxcbiAgICAgICAgICBtYXRjaGluZ0VudHJ5Lm5hbWVcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIGVudHJ5O1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAncmVuZGVyTWF0Y2hDb3VudCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlck1hdGNoQ291bnQobWF0Y2hDb3VudCkge1xuICAgICAgLy8gb3B0aW9uYWxcbiAgICAgIHJldHVybiB0aGlzLnByb3BzLmN1c3RvbU1hdGNoQ291bnRDb21wb25lbnQgPyB0aGlzLnByb3BzLmN1c3RvbU1hdGNoQ291bnRDb21wb25lbnQobWF0Y2hDb3VudCkgOiBfcmVhY3QyLmRlZmF1bHQuY3JlYXRlRWxlbWVudChcbiAgICAgICAgJ2RpdicsXG4gICAgICAgIHsgY2xhc3NOYW1lOiAndW5pdi1zZWFyY2gtbWF0Y2gtY291bnQnLCBzdHlsZTogeyBtYXJnaW5Ub3A6ICcxMHB4JywgY29sb3I6ICcjYWFhJyB9IH0sXG4gICAgICAgIG1hdGNoQ291bnQsXG4gICAgICAgICcgTWF0Y2hlcydcbiAgICAgICk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAncmVuZGVySWZOb01hdGNoZXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXJJZk5vTWF0Y2hlcyhxdWVyeSkge1xuICAgICAgLy8gYWxzbyBvcHRpb25hbFxuXG4gICAgICAvLyBkbyBub3Qgc2hvdyBcIm5vIG1hdGNoZXMgZm91bmRcIiBtZXNzYWdlIGlmIG5vIHF1ZXJ5XG4gICAgICAvLyBtYXkgY2hhbmdlIHRoaXMgdG8gYW4gb3B0aW9uIGxhdGVyXG4gICAgICBpZiAoIXF1ZXJ5KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMucHJvcHMuY3VzdG9tTm9NYXRjaENvbXBvbmVudCA/IHRoaXMucHJvcHMuY3VzdG9tTm9NYXRjaENvbXBvbmVudCA6IF9yZWFjdDIuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAnZGl2JyxcbiAgICAgICAgeyBjbGFzc05hbWU6ICd1bml2LXNlYXJjaC1uby1tYXRjaGVzJyB9LFxuICAgICAgICAnTm8gTWF0Y2hlcy4uLidcbiAgICAgICk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZm9jdXNIYW5kbGVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZm9jdXNIYW5kbGVyKCkge1xuICAgICAgaWYgKHRoaXMucHJvcHMuZm9jdXNlZE9ubHkpIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgZm9jdXNlZDogIXRoaXMuc3RhdGUuZm9jdXNlZFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdyZW5kZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICB2YXIgbWF0Y2hlc0ZvdW5kID0gdGhpcy5zdGF0ZS5yZXN1bHRzLnNpemUgPiAwO1xuXG4gICAgICB2YXIgbWF0Y2hDb3VudENvbXBvbmVudCA9IHRoaXMucHJvcHMuc2hvd01hdGNoQ291bnQgfHwgdGhpcy5wcm9wcy5jdXN0b21NYXRjaENvdW50Q29tcG9uZW50ID8gdGhpcy5yZW5kZXJNYXRjaENvdW50KHRoaXMuc3RhdGUucmVzdWx0cy5zaXplKSA6IG51bGw7XG4gICAgICB2YXIgbm9NYXRjaENvbXBvbmVudCA9IHRoaXMucHJvcHMuc2hvd1doZW5Ob01hdGNoZXMgfHwgdGhpcy5wcm9wcy5jdXN0b21Ob01hdGNoQ29tcG9uZW50ID8gdGhpcy5yZW5kZXJJZk5vTWF0Y2hlcyh0aGlzLnN0YXRlLnF1ZXJ5KSA6IG51bGw7XG5cbiAgICAgIHZhciBtYXRjaGluZ0l0ZW1FbGVtZW50cyA9IG1hdGNoZXNGb3VuZCA/IHRoaXMucmVuZGVyTWF0Y2hlcyh0aGlzLnN0YXRlLnJlc3VsdHMpIDogbm9NYXRjaENvbXBvbmVudDtcblxuICAgICAgdmFyIHNob3dSZXN1bHRzID0gdGhpcy5zdGF0ZS5xdWVyeSAmJiAhdGhpcy5zdGF0ZS5xdWVyeS5tYXRjaCgvXlxccyskL2lnbSkgJiYgdGhpcy5zdGF0ZS5mb2N1c2VkO1xuXG4gICAgICByZXR1cm4gX3JlYWN0Mi5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICdkaXYnLFxuICAgICAgICB7IGNsYXNzTmFtZTogJ3VuaXYtc2VhcmNoLXdyYXBwZXInIH0sXG4gICAgICAgIF9yZWFjdDIuZGVmYXVsdC5jcmVhdGVFbGVtZW50KCdpbnB1dCcsIHtcbiAgICAgICAgICBwbGFjZWhvbGRlcjogdGhpcy5wcm9wcy5wbGFjZWhvbGRlcixcbiAgICAgICAgICBvbkNoYW5nZTogdGhpcy5pbnB1dFF1ZXJ5LFxuICAgICAgICAgIG9uRm9jdXM6IHRoaXMuZm9jdXNIYW5kbGVyLFxuICAgICAgICAgIG9uQmx1cjogdGhpcy5mb2N1c0hhbmRsZXJcbiAgICAgICAgfSksXG4gICAgICAgIG1hdGNoQ291bnRDb21wb25lbnQsXG4gICAgICAgIF9yZWFjdDIuZGVmYXVsdC5jcmVhdGVFbGVtZW50KCdicicsIG51bGwpLFxuICAgICAgICBfcmVhY3QyLmRlZmF1bHQuY3JlYXRlRWxlbWVudCgnYnInLCBudWxsKSxcbiAgICAgICAgX3JlYWN0Mi5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgJ2RpdicsXG4gICAgICAgICAge1xuICAgICAgICAgICAgY2xhc3NOYW1lOiAndW5pdi1zZWFyY2gtcmVzdWx0cy13cmFwcGVyJyxcbiAgICAgICAgICAgIHN0eWxlOiB7IGRpc3BsYXk6IHNob3dSZXN1bHRzID8gJ2luaGVyaXQnIDogJ25vbmUnIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIG1hdGNoaW5nSXRlbUVsZW1lbnRzXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFVuaXZlcnNhbFNlYXJjaDtcbn0oX3JlYWN0Mi5kZWZhdWx0LkNvbXBvbmVudCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFVuaXZlcnNhbFNlYXJjaDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9Vbml2ZXJzYWxTZWFyY2guanNcbi8vIG1vZHVsZSBpZCA9IDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///0\n")},function(module,exports){eval("module.exports = __WEBPACK_EXTERNAL_MODULE_1__;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9leHRlcm5hbCBcInJlYWN0XCI/M2M2MiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfMV9fO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwicmVhY3RcIlxuLy8gbW9kdWxlIGlkID0gMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1\n")}])});