!function(t,e){"object"==typeof exports&&"object"==typeof module?module.exports=e(require("react")):"function"==typeof define&&define.amd?define(["react"],e):"object"==typeof exports?exports.UniversalSearch=e(require("react")):t.UniversalSearch=e(t.react)}(this,function(__WEBPACK_EXTERNAL_MODULE_1__){return function(t){function e(I){if(c[I])return c[I].exports;var g=c[I]={i:I,l:!1,exports:{}};return t[I].call(g.exports,g,g.exports,e),g.l=!0,g.exports}var c={};return e.m=t,e.c=c,e.d=function(t,c,I){e.o(t,c)||Object.defineProperty(t,c,{configurable:!1,enumerable:!0,get:I})},e.n=function(t){var c=t&&t.__esModule?function(){return t.default}:function(){return t};return e.d(c,"a",c),c},e.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},e.p="",e(e.s=0)}([function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _react = __webpack_require__(1);\n\nvar _react2 = _interopRequireDefault(_react);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar UniversalSearch = function (_React$Component) {\n  _inherits(UniversalSearch, _React$Component);\n\n  function UniversalSearch(props) {\n    _classCallCheck(this, UniversalSearch);\n\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set\n\n    // this library uses an ES6 Set()\n    // typically, we get O(1) across the board with this data structure\n    var _this = _possibleConstructorReturn(this, (UniversalSearch.__proto__ || Object.getPrototypeOf(UniversalSearch)).call(this, props));\n\n    _this.state = {\n      query: '',\n      results: new Set()\n    };\n\n    _this.checkForCategories = _this.checkForCategories.bind(_this);\n    _this.inputQuery = _this.inputQuery.bind(_this);\n    _this.filterMatches = _this.filterMatches.bind(_this);\n    _this.renderMatches = _this.renderMatches.bind(_this);\n    _this.renderMatchCount = _this.renderMatchCount.bind(_this);\n\n    // check if categories were explicitly passed\n    // if not, iterate through the Object keys\n    // and see if category inclusion can be detected from structure\n    _this.includeCategories = typeof _this.includeCategories !== 'undefined' ? _this.props.hasCategories : _this.checkForCategories(props.listToSearch);\n    return _this;\n  }\n\n  _createClass(UniversalSearch, [{\n    key: 'checkForCategories',\n    value: function checkForCategories(listToSearch) {\n      var listKeys = Object.keys(listToSearch);\n      for (var i = 0; i < listKeys.length; i++) {\n        if (Array.isArray(listToSearch[listKeys[i]])) {\n          // short-circuit if following the Object --\x3e Array structure\n          return true;\n        }\n      }\n      // if not, assume regular array\n      return false;\n    }\n  }, {\n    key: 'inputQuery',\n    value: function inputQuery(e) {\n      // escape input and build RE query\n      var input = e.target.value.replace(/[\\.\\+\\*\\?\\^\\$\\[\\]\\{\\}\\(\\)\\|\\/\\\\]/ig, function (sym) {\n        return '\\\\' + sym;\n      });\n      var re = input.trim().length > 0 ? new RegExp(input.trim(), 'gi') : '';\n\n      this.setState({\n        query: input\n      });\n\n      if (input) {\n        // use our RE matches to filter on matching strings\n        this.filterMatches(re);\n      } else {\n        // clear all results if search string is empty\n        this.state.results.clear();\n      }\n    }\n  }, {\n    key: 'filterMatches',\n    value: function filterMatches(re) {\n      var _this2 = this;\n\n      var scan = function scan(inputArr, category) {\n        // we need this offset to see if we're below a limit if one is specified\n        // and/or to see if the category header needs to move down\n        var offset = 0;\n        var showing = 0;\n        for (var i = 0; i < inputArr.length; i++) {\n          var item = inputArr[i];\n          if (item.name.match(re) && re !== '') {\n            showing++;\n            // if string matches\n            if (offset - i === 0) {\n              // if first match in new category, add _firstInCategory property\n              // this will be used as a flag to render the category header below.\n              item._firstInCategory = true;\n            }\n            item._category = category;\n            _this2.state.results.add(item);\n\n            // if a limit was passed in, check if we've exceeded it\n            // if so, bail out\n            if (_this2.props.limitResults && showing >= _this2.props.limitResults) {\n              return;\n            }\n          } else if (_this2.state.results.has(item) && re !== '') {\n            // if no match, but present in previous result set, delete and increment\n            // offset\n            _this2.state.results.delete(item);\n            offset++;\n          } else {\n            // if for any reason an empty item exists, just increment the offset\n            offset++;\n          }\n        }\n      };\n\n      if (this.includeCategories) {\n        // if there are categories, iterate through the contents of each one separately\n        Object.keys(this.props.listToSearch).forEach(function (category) {\n          scan(_this2.props.listToSearch[category], category);\n        });\n      } else {\n        // otherwise, simply iterate through a single array\n        scan(this.props.listToSearch);\n      }\n    }\n  }, {\n    key: 'renderMatches',\n    value: function renderMatches(resultsSet) {\n      var _this3 = this;\n\n      // we use a Spread Operator to temporarily transform a Set into an Array\n      // this makes it easier to map into React\n      return [].concat(_toConsumableArray(resultsSet)).map(function (matchingEntry, i) {\n        if (_this3.props.customComponent) {\n          return _this3.props.customComponent(matchingEntry, i);\n        }\n        // default structure if not specified\n        var entry = _react2.default.createElement(\n          'div',\n          {\n            className: 'univ-search-matching-results ' + (matchingEntry._firstInCategory ? 'univ-search-category-head' : ''),\n            key: 'match_' + i\n          },\n          _this3.includeCategories && matchingEntry._firstInCategory ? _react2.default.createElement(\n            'div',\n            {\n              className: 'univ-search-category-head',\n              style: { color: '#aaa', fontStyle: 'italic', fontSize: '12px', margin: '10px 0' }\n            },\n            matchingEntry._category\n          ) : null,\n          matchingEntry.name\n        );\n        return entry;\n      });\n    }\n  }, {\n    key: 'renderMatchCount',\n    value: function renderMatchCount(matchCount) {\n      // optional\n      return this.props.customMatchCountComponent ? this.props.customMatchCountComponent(matchCount) : _react2.default.createElement(\n        'div',\n        { className: 'univ-search-match-count', style: { marginTop: '10px', color: '#aaa' } },\n        matchCount,\n        ' Matches'\n      );\n    }\n  }, {\n    key: 'render',\n    value: function render() {\n      var noMatchMessage = _react2.default.createElement(\n        'div',\n        null,\n        'No Matches...'\n      );\n      if (!this.state.query || this.props.hideNoMatchMessage) {\n        noMatchMessage = null;\n      }\n      var matchCountComponent = this.props.showMatchCount ? this.renderMatchCount(this.state.results.size) : null;\n      var matchingItemElements = this.state.results.size > 0 ? this.renderMatches(this.state.results) : noMatchMessage;\n\n      return _react2.default.createElement(\n        'div',\n        { className: 'univ-search-wrapper' },\n        _react2.default.createElement('input', { onChange: this.inputQuery }),\n        this.props.placeholder,\n        this.props.showMatchCount ? matchCountComponent : null,\n        _react2.default.createElement('br', null),\n        _react2.default.createElement('br', null),\n        _react2.default.createElement(\n          'div',\n          { className: 'univ-search-results-wrapper' },\n          matchingItemElements\n        )\n      );\n    }\n  }]);\n\n  return UniversalSearch;\n}(_react2.default.Component);\n\nexports.default = UniversalSearch;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9Vbml2ZXJzYWxTZWFyY2guanM/MzM3ZSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gQXJyYXkoYXJyLmxlbmd0aCk7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfSBlbHNlIHsgcmV0dXJuIEFycmF5LmZyb20oYXJyKTsgfSB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIFVuaXZlcnNhbFNlYXJjaCA9IGZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0cyhVbml2ZXJzYWxTZWFyY2gsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIFVuaXZlcnNhbFNlYXJjaChwcm9wcykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBVbml2ZXJzYWxTZWFyY2gpO1xuXG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU2V0XG5cbiAgICAvLyB0aGlzIGxpYnJhcnkgdXNlcyBhbiBFUzYgU2V0KClcbiAgICAvLyB0eXBpY2FsbHksIHdlIGdldCBPKDEpIGFjcm9zcyB0aGUgYm9hcmQgd2l0aCB0aGlzIGRhdGEgc3RydWN0dXJlXG4gICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKFVuaXZlcnNhbFNlYXJjaC5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFVuaXZlcnNhbFNlYXJjaCkpLmNhbGwodGhpcywgcHJvcHMpKTtcblxuICAgIF90aGlzLnN0YXRlID0ge1xuICAgICAgcXVlcnk6ICcnLFxuICAgICAgcmVzdWx0czogbmV3IFNldCgpXG4gICAgfTtcblxuICAgIF90aGlzLmNoZWNrRm9yQ2F0ZWdvcmllcyA9IF90aGlzLmNoZWNrRm9yQ2F0ZWdvcmllcy5iaW5kKF90aGlzKTtcbiAgICBfdGhpcy5pbnB1dFF1ZXJ5ID0gX3RoaXMuaW5wdXRRdWVyeS5iaW5kKF90aGlzKTtcbiAgICBfdGhpcy5maWx0ZXJNYXRjaGVzID0gX3RoaXMuZmlsdGVyTWF0Y2hlcy5iaW5kKF90aGlzKTtcbiAgICBfdGhpcy5yZW5kZXJNYXRjaGVzID0gX3RoaXMucmVuZGVyTWF0Y2hlcy5iaW5kKF90aGlzKTtcbiAgICBfdGhpcy5yZW5kZXJNYXRjaENvdW50ID0gX3RoaXMucmVuZGVyTWF0Y2hDb3VudC5iaW5kKF90aGlzKTtcblxuICAgIC8vIGNoZWNrIGlmIGNhdGVnb3JpZXMgd2VyZSBleHBsaWNpdGx5IHBhc3NlZFxuICAgIC8vIGlmIG5vdCwgaXRlcmF0ZSB0aHJvdWdoIHRoZSBPYmplY3Qga2V5c1xuICAgIC8vIGFuZCBzZWUgaWYgY2F0ZWdvcnkgaW5jbHVzaW9uIGNhbiBiZSBkZXRlY3RlZCBmcm9tIHN0cnVjdHVyZVxuICAgIF90aGlzLmluY2x1ZGVDYXRlZ29yaWVzID0gdHlwZW9mIF90aGlzLmluY2x1ZGVDYXRlZ29yaWVzICE9PSAndW5kZWZpbmVkJyA/IF90aGlzLnByb3BzLmhhc0NhdGVnb3JpZXMgOiBfdGhpcy5jaGVja0ZvckNhdGVnb3JpZXMocHJvcHMubGlzdFRvU2VhcmNoKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoVW5pdmVyc2FsU2VhcmNoLCBbe1xuICAgIGtleTogJ2NoZWNrRm9yQ2F0ZWdvcmllcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNoZWNrRm9yQ2F0ZWdvcmllcyhsaXN0VG9TZWFyY2gpIHtcbiAgICAgIHZhciBsaXN0S2V5cyA9IE9iamVjdC5rZXlzKGxpc3RUb1NlYXJjaCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3RLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGxpc3RUb1NlYXJjaFtsaXN0S2V5c1tpXV0pKSB7XG4gICAgICAgICAgLy8gc2hvcnQtY2lyY3VpdCBpZiBmb2xsb3dpbmcgdGhlIE9iamVjdCAtLT4gQXJyYXkgc3RydWN0dXJlXG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIGlmIG5vdCwgYXNzdW1lIHJlZ3VsYXIgYXJyYXlcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdpbnB1dFF1ZXJ5JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5wdXRRdWVyeShlKSB7XG4gICAgICAvLyBlc2NhcGUgaW5wdXQgYW5kIGJ1aWxkIFJFIHF1ZXJ5XG4gICAgICB2YXIgaW5wdXQgPSBlLnRhcmdldC52YWx1ZS5yZXBsYWNlKC9bXFwuXFwrXFwqXFw/XFxeXFwkXFxbXFxdXFx7XFx9XFwoXFwpXFx8XFwvXFxcXF0vaWcsIGZ1bmN0aW9uIChzeW0pIHtcbiAgICAgICAgcmV0dXJuICdcXFxcJyArIHN5bTtcbiAgICAgIH0pO1xuICAgICAgdmFyIHJlID0gaW5wdXQudHJpbSgpLmxlbmd0aCA+IDAgPyBuZXcgUmVnRXhwKGlucHV0LnRyaW0oKSwgJ2dpJykgOiAnJztcblxuICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIHF1ZXJ5OiBpbnB1dFxuICAgICAgfSk7XG5cbiAgICAgIGlmIChpbnB1dCkge1xuICAgICAgICAvLyB1c2Ugb3VyIFJFIG1hdGNoZXMgdG8gZmlsdGVyIG9uIG1hdGNoaW5nIHN0cmluZ3NcbiAgICAgICAgdGhpcy5maWx0ZXJNYXRjaGVzKHJlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGNsZWFyIGFsbCByZXN1bHRzIGlmIHNlYXJjaCBzdHJpbmcgaXMgZW1wdHlcbiAgICAgICAgdGhpcy5zdGF0ZS5yZXN1bHRzLmNsZWFyKCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZmlsdGVyTWF0Y2hlcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpbHRlck1hdGNoZXMocmUpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB2YXIgc2NhbiA9IGZ1bmN0aW9uIHNjYW4oaW5wdXRBcnIsIGNhdGVnb3J5KSB7XG4gICAgICAgIC8vIHdlIG5lZWQgdGhpcyBvZmZzZXQgdG8gc2VlIGlmIHdlJ3JlIGJlbG93IGEgbGltaXQgaWYgb25lIGlzIHNwZWNpZmllZFxuICAgICAgICAvLyBhbmQvb3IgdG8gc2VlIGlmIHRoZSBjYXRlZ29yeSBoZWFkZXIgbmVlZHMgdG8gbW92ZSBkb3duXG4gICAgICAgIHZhciBvZmZzZXQgPSAwO1xuICAgICAgICB2YXIgc2hvd2luZyA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5wdXRBcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgaXRlbSA9IGlucHV0QXJyW2ldO1xuICAgICAgICAgIGlmIChpdGVtLm5hbWUubWF0Y2gocmUpICYmIHJlICE9PSAnJykge1xuICAgICAgICAgICAgc2hvd2luZysrO1xuICAgICAgICAgICAgLy8gaWYgc3RyaW5nIG1hdGNoZXNcbiAgICAgICAgICAgIGlmIChvZmZzZXQgLSBpID09PSAwKSB7XG4gICAgICAgICAgICAgIC8vIGlmIGZpcnN0IG1hdGNoIGluIG5ldyBjYXRlZ29yeSwgYWRkIF9maXJzdEluQ2F0ZWdvcnkgcHJvcGVydHlcbiAgICAgICAgICAgICAgLy8gdGhpcyB3aWxsIGJlIHVzZWQgYXMgYSBmbGFnIHRvIHJlbmRlciB0aGUgY2F0ZWdvcnkgaGVhZGVyIGJlbG93LlxuICAgICAgICAgICAgICBpdGVtLl9maXJzdEluQ2F0ZWdvcnkgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaXRlbS5fY2F0ZWdvcnkgPSBjYXRlZ29yeTtcbiAgICAgICAgICAgIF90aGlzMi5zdGF0ZS5yZXN1bHRzLmFkZChpdGVtKTtcblxuICAgICAgICAgICAgLy8gaWYgYSBsaW1pdCB3YXMgcGFzc2VkIGluLCBjaGVjayBpZiB3ZSd2ZSBleGNlZWRlZCBpdFxuICAgICAgICAgICAgLy8gaWYgc28sIGJhaWwgb3V0XG4gICAgICAgICAgICBpZiAoX3RoaXMyLnByb3BzLmxpbWl0UmVzdWx0cyAmJiBzaG93aW5nID49IF90aGlzMi5wcm9wcy5saW1pdFJlc3VsdHMpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoX3RoaXMyLnN0YXRlLnJlc3VsdHMuaGFzKGl0ZW0pICYmIHJlICE9PSAnJykge1xuICAgICAgICAgICAgLy8gaWYgbm8gbWF0Y2gsIGJ1dCBwcmVzZW50IGluIHByZXZpb3VzIHJlc3VsdCBzZXQsIGRlbGV0ZSBhbmQgaW5jcmVtZW50XG4gICAgICAgICAgICAvLyBvZmZzZXRcbiAgICAgICAgICAgIF90aGlzMi5zdGF0ZS5yZXN1bHRzLmRlbGV0ZShpdGVtKTtcbiAgICAgICAgICAgIG9mZnNldCsrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBpZiBmb3IgYW55IHJlYXNvbiBhbiBlbXB0eSBpdGVtIGV4aXN0cywganVzdCBpbmNyZW1lbnQgdGhlIG9mZnNldFxuICAgICAgICAgICAgb2Zmc2V0Kys7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5pbmNsdWRlQ2F0ZWdvcmllcykge1xuICAgICAgICAvLyBpZiB0aGVyZSBhcmUgY2F0ZWdvcmllcywgaXRlcmF0ZSB0aHJvdWdoIHRoZSBjb250ZW50cyBvZiBlYWNoIG9uZSBzZXBhcmF0ZWx5XG4gICAgICAgIE9iamVjdC5rZXlzKHRoaXMucHJvcHMubGlzdFRvU2VhcmNoKS5mb3JFYWNoKGZ1bmN0aW9uIChjYXRlZ29yeSkge1xuICAgICAgICAgIHNjYW4oX3RoaXMyLnByb3BzLmxpc3RUb1NlYXJjaFtjYXRlZ29yeV0sIGNhdGVnb3J5KTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBvdGhlcndpc2UsIHNpbXBseSBpdGVyYXRlIHRocm91Z2ggYSBzaW5nbGUgYXJyYXlcbiAgICAgICAgc2Nhbih0aGlzLnByb3BzLmxpc3RUb1NlYXJjaCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAncmVuZGVyTWF0Y2hlcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlck1hdGNoZXMocmVzdWx0c1NldCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIC8vIHdlIHVzZSBhIFNwcmVhZCBPcGVyYXRvciB0byB0ZW1wb3JhcmlseSB0cmFuc2Zvcm0gYSBTZXQgaW50byBhbiBBcnJheVxuICAgICAgLy8gdGhpcyBtYWtlcyBpdCBlYXNpZXIgdG8gbWFwIGludG8gUmVhY3RcbiAgICAgIHJldHVybiBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KHJlc3VsdHNTZXQpKS5tYXAoZnVuY3Rpb24gKG1hdGNoaW5nRW50cnksIGkpIHtcbiAgICAgICAgaWYgKF90aGlzMy5wcm9wcy5jdXN0b21Db21wb25lbnQpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMzLnByb3BzLmN1c3RvbUNvbXBvbmVudChtYXRjaGluZ0VudHJ5LCBpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBkZWZhdWx0IHN0cnVjdHVyZSBpZiBub3Qgc3BlY2lmaWVkXG4gICAgICAgIHZhciBlbnRyeSA9IF9yZWFjdDIuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICdkaXYnLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogJ3VuaXYtc2VhcmNoLW1hdGNoaW5nLXJlc3VsdHMgJyArIChtYXRjaGluZ0VudHJ5Ll9maXJzdEluQ2F0ZWdvcnkgPyAndW5pdi1zZWFyY2gtY2F0ZWdvcnktaGVhZCcgOiAnJyksXG4gICAgICAgICAgICBrZXk6ICdtYXRjaF8nICsgaVxuICAgICAgICAgIH0sXG4gICAgICAgICAgX3RoaXMzLmluY2x1ZGVDYXRlZ29yaWVzICYmIG1hdGNoaW5nRW50cnkuX2ZpcnN0SW5DYXRlZ29yeSA/IF9yZWFjdDIuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgJ2RpdicsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGNsYXNzTmFtZTogJ3VuaXYtc2VhcmNoLWNhdGVnb3J5LWhlYWQnLFxuICAgICAgICAgICAgICBzdHlsZTogeyBjb2xvcjogJyNhYWEnLCBmb250U3R5bGU6ICdpdGFsaWMnLCBmb250U2l6ZTogJzEycHgnLCBtYXJnaW46ICcxMHB4IDAnIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtYXRjaGluZ0VudHJ5Ll9jYXRlZ29yeVxuICAgICAgICAgICkgOiBudWxsLFxuICAgICAgICAgIG1hdGNoaW5nRW50cnkubmFtZVxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gZW50cnk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdyZW5kZXJNYXRjaENvdW50JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyTWF0Y2hDb3VudChtYXRjaENvdW50KSB7XG4gICAgICAvLyBvcHRpb25hbFxuICAgICAgcmV0dXJuIHRoaXMucHJvcHMuY3VzdG9tTWF0Y2hDb3VudENvbXBvbmVudCA/IHRoaXMucHJvcHMuY3VzdG9tTWF0Y2hDb3VudENvbXBvbmVudChtYXRjaENvdW50KSA6IF9yZWFjdDIuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAnZGl2JyxcbiAgICAgICAgeyBjbGFzc05hbWU6ICd1bml2LXNlYXJjaC1tYXRjaC1jb3VudCcsIHN0eWxlOiB7IG1hcmdpblRvcDogJzEwcHgnLCBjb2xvcjogJyNhYWEnIH0gfSxcbiAgICAgICAgbWF0Y2hDb3VudCxcbiAgICAgICAgJyBNYXRjaGVzJ1xuICAgICAgKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdyZW5kZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICB2YXIgbm9NYXRjaE1lc3NhZ2UgPSBfcmVhY3QyLmRlZmF1bHQuY3JlYXRlRWxlbWVudChcbiAgICAgICAgJ2RpdicsXG4gICAgICAgIG51bGwsXG4gICAgICAgICdObyBNYXRjaGVzLi4uJ1xuICAgICAgKTtcbiAgICAgIGlmICghdGhpcy5zdGF0ZS5xdWVyeSB8fCB0aGlzLnByb3BzLmhpZGVOb01hdGNoTWVzc2FnZSkge1xuICAgICAgICBub01hdGNoTWVzc2FnZSA9IG51bGw7XG4gICAgICB9XG4gICAgICB2YXIgbWF0Y2hDb3VudENvbXBvbmVudCA9IHRoaXMucHJvcHMuc2hvd01hdGNoQ291bnQgPyB0aGlzLnJlbmRlck1hdGNoQ291bnQodGhpcy5zdGF0ZS5yZXN1bHRzLnNpemUpIDogbnVsbDtcbiAgICAgIHZhciBtYXRjaGluZ0l0ZW1FbGVtZW50cyA9IHRoaXMuc3RhdGUucmVzdWx0cy5zaXplID4gMCA/IHRoaXMucmVuZGVyTWF0Y2hlcyh0aGlzLnN0YXRlLnJlc3VsdHMpIDogbm9NYXRjaE1lc3NhZ2U7XG5cbiAgICAgIHJldHVybiBfcmVhY3QyLmRlZmF1bHQuY3JlYXRlRWxlbWVudChcbiAgICAgICAgJ2RpdicsXG4gICAgICAgIHsgY2xhc3NOYW1lOiAndW5pdi1zZWFyY2gtd3JhcHBlcicgfSxcbiAgICAgICAgX3JlYWN0Mi5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoJ2lucHV0JywgeyBvbkNoYW5nZTogdGhpcy5pbnB1dFF1ZXJ5IH0pLFxuICAgICAgICB0aGlzLnByb3BzLnBsYWNlaG9sZGVyLFxuICAgICAgICB0aGlzLnByb3BzLnNob3dNYXRjaENvdW50ID8gbWF0Y2hDb3VudENvbXBvbmVudCA6IG51bGwsXG4gICAgICAgIF9yZWFjdDIuZGVmYXVsdC5jcmVhdGVFbGVtZW50KCdicicsIG51bGwpLFxuICAgICAgICBfcmVhY3QyLmRlZmF1bHQuY3JlYXRlRWxlbWVudCgnYnInLCBudWxsKSxcbiAgICAgICAgX3JlYWN0Mi5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgJ2RpdicsXG4gICAgICAgICAgeyBjbGFzc05hbWU6ICd1bml2LXNlYXJjaC1yZXN1bHRzLXdyYXBwZXInIH0sXG4gICAgICAgICAgbWF0Y2hpbmdJdGVtRWxlbWVudHNcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gVW5pdmVyc2FsU2VhcmNoO1xufShfcmVhY3QyLmRlZmF1bHQuQ29tcG9uZW50KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gVW5pdmVyc2FsU2VhcmNoO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL1VuaXZlcnNhbFNlYXJjaC5qc1xuLy8gbW9kdWxlIGlkID0gMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///0\n")},function(module,exports){eval("module.exports = __WEBPACK_EXTERNAL_MODULE_1__;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9leHRlcm5hbCBcInJlYWN0XCI/M2M2MiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfMV9fO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwicmVhY3RcIlxuLy8gbW9kdWxlIGlkID0gMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1\n")}])});