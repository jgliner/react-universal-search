!function(t,c){"object"==typeof exports&&"object"==typeof module?module.exports=c(require("react")):"function"==typeof define&&define.amd?define(["react"],c):"object"==typeof exports?exports.UniversalSearch=c(require("react")):t.UniversalSearch=c(t.react)}(this,function(__WEBPACK_EXTERNAL_MODULE_1__){return function(t){function c(g){if(e[g])return e[g].exports;var I=e[g]={i:g,l:!1,exports:{}};return t[g].call(I.exports,I,I.exports,c),I.l=!0,I.exports}var e={};return c.m=t,c.c=e,c.d=function(t,e,g){c.o(t,e)||Object.defineProperty(t,e,{configurable:!1,enumerable:!0,get:g})},c.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return c.d(e,"a",e),e},c.o=function(t,c){return Object.prototype.hasOwnProperty.call(t,c)},c.p="",c(c.s=0)}([function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _react = __webpack_require__(1);\n\nvar _react2 = _interopRequireDefault(_react);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar UniversalSearch = function (_React$Component) {\n  _inherits(UniversalSearch, _React$Component);\n\n  function UniversalSearch(props) {\n    _classCallCheck(this, UniversalSearch);\n\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set\n\n    // this library uses an ES6 Set()\n    // typically, we get O(1) across the board with this data structure\n    var _this = _possibleConstructorReturn(this, (UniversalSearch.__proto__ || Object.getPrototypeOf(UniversalSearch)).call(this, props));\n\n    _this.state = {\n      query: '',\n      results: new Set()\n    };\n\n    _this.checkForCategories = _this.checkForCategories.bind(_this);\n    _this.inputQuery = _this.inputQuery.bind(_this);\n    _this.filterMatches = _this.filterMatches.bind(_this);\n    _this.renderMatches = _this.renderMatches.bind(_this);\n    _this.renderMatchCount = _this.renderMatchCount.bind(_this);\n\n    // check if categories were explicitly passed\n    // if not, iterate through the Object keys\n    // and see if category inclusion can be detected from structure\n    _this.includeCategories = typeof _this.includeCategories !== 'undefined' ? _this.props.hasCategories : _this.checkForCategories(props.listToSearch);\n    return _this;\n  }\n\n  _createClass(UniversalSearch, [{\n    key: 'checkForCategories',\n    value: function checkForCategories(listToSearch) {\n      var listKeys = Object.keys(listToSearch);\n      for (var i = 0; i < listKeys.length; i++) {\n        if (Array.isArray(listToSearch[listKeys[i]])) {\n          // short-circuit if following the Object --\x3e Array structure\n          return true;\n        }\n      }\n      // if not, assume regular array\n      return false;\n    }\n  }, {\n    key: 'inputQuery',\n    value: function inputQuery(e) {\n      // escape input and build RE query\n      var input = e.target.value.replace(/[\\.\\+\\*\\?\\^\\$\\[\\]\\{\\}\\(\\)\\|\\/\\\\]/ig, function (sym) {\n        return '\\\\' + sym;\n      });\n      var re = input.trim().length > 0 ? new RegExp(input.trim(), 'gi') : '';\n\n      this.setState({\n        query: input\n      });\n\n      if (input) {\n        // use our RE matches to filter on matching strings\n        this.filterMatches(re);\n      } else {\n        // clear all results if search string is empty\n        this.state.results.clear();\n      }\n    }\n  }, {\n    key: 'filterMatches',\n    value: function filterMatches(re) {\n      var _this2 = this;\n\n      var scan = function scan(inputArr, category) {\n        // we need this offset to see if we're below a limit if one is specified\n        // and/or to see if the category header needs to move down\n        var offset = 0;\n        for (var i = 0; i < inputArr.length; i++) {\n          var item = inputArr[i];\n          if (item.name.match(re) && re !== '') {\n            // if string matches\n            if (offset - i === 0) {\n              // if first match in new category, add _firstInCategory property\n              // this will be used as a flag to render the category header below.\n              item._firstInCategory = true;\n            }\n            item._category = category;\n            _this2.state.results.add(item);\n\n            // if a limit was passed in, check if we've exceeded it\n            // if so, bail out\n            if (_this2.props.limitResults && offset - i + 1 > _this2.props.limitResults) {\n              return;\n            }\n          } else if (_this2.state.results.has(item) && re !== '') {\n            // if no match, but present in previous result set, delete and increment\n            // offset\n            _this2.state.results.delete(item);\n            offset++;\n          } else {\n            // if for any reason an empty item exists, just increment the offset\n            offset++;\n          }\n        }\n      };\n\n      if (this.includeCategories) {\n        // if there are categories, iterate through the contents of each one separately\n        Object.keys(this.props.listToSearch).forEach(function (category) {\n          scan(_this2.props.listToSearch[category], category);\n        });\n      } else {\n        // otherwise, simply iterate through a single array\n        scan(this.props.listToSearch);\n      }\n    }\n  }, {\n    key: 'renderMatches',\n    value: function renderMatches(resultsSet) {\n      var _this3 = this;\n\n      // we use a Spread Operator to temporarily transform a Set into an Array\n      // this makes it easier to map into React\n      return [].concat(_toConsumableArray(resultsSet)).map(function (matchingEntry, i) {\n        if (_this3.props.customComponent) {\n          return _this3.props.customComponent(matchingEntry, i);\n        }\n        // default structure if not specified\n        var entry = _react2.default.createElement(\n          'div',\n          {\n            className: 'univ-search-matching-results ' + (matchingEntry._firstInCategory ? 'univ-search-category-head' : ''),\n            key: 'match_' + i\n          },\n          _this3.includeCategories && matchingEntry._firstInCategory ? _react2.default.createElement(\n            'div',\n            {\n              className: 'univ-search-category-head',\n              style: { color: '#aaa', fontStyle: 'italic', fontSize: '12px', margin: '10px 0' }\n            },\n            matchingEntry._category\n          ) : null,\n          matchingEntry.name\n        );\n        return entry;\n      });\n    }\n  }, {\n    key: 'renderMatchCount',\n    value: function renderMatchCount(matchCount) {\n      // optional\n      return this.props.customMatchCountComponent ? this.props.customMatchCountComponent(matchCount) : _react2.default.createElement(\n        'div',\n        { className: 'univ-search-match-count', style: { marginTop: '10px', color: '#aaa' } },\n        matchCount,\n        ' Matches'\n      );\n    }\n  }, {\n    key: 'render',\n    value: function render() {\n      var noMatchMessage = _react2.default.createElement(\n        'div',\n        null,\n        'No Matches...'\n      );\n      if (!this.state.query || this.props.hideNoMatchMessage) {\n        noMatchMessage = null;\n      }\n      var matchCountComponent = this.props.showMatchCount ? this.renderMatchCount(this.state.results.size) : null;\n      var matchingItemElements = this.state.results.size > 0 ? this.renderMatches(this.state.results) : noMatchMessage;\n\n      return _react2.default.createElement(\n        'div',\n        { className: 'univ-search-wrapper' },\n        _react2.default.createElement('input', { onChange: this.inputQuery }),\n        this.props.placeholder,\n        this.props.showMatchCount ? matchCountComponent : null,\n        _react2.default.createElement('br', null),\n        _react2.default.createElement('br', null),\n        _react2.default.createElement(\n          'div',\n          { className: 'univ-search-results-wrapper' },\n          matchingItemElements\n        )\n      );\n    }\n  }]);\n\n  return UniversalSearch;\n}(_react2.default.Component);\n\nexports.default = UniversalSearch;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9Vbml2ZXJzYWxTZWFyY2guanM/MzM3ZSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gQXJyYXkoYXJyLmxlbmd0aCk7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfSBlbHNlIHsgcmV0dXJuIEFycmF5LmZyb20oYXJyKTsgfSB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIFVuaXZlcnNhbFNlYXJjaCA9IGZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0cyhVbml2ZXJzYWxTZWFyY2gsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIFVuaXZlcnNhbFNlYXJjaChwcm9wcykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBVbml2ZXJzYWxTZWFyY2gpO1xuXG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU2V0XG5cbiAgICAvLyB0aGlzIGxpYnJhcnkgdXNlcyBhbiBFUzYgU2V0KClcbiAgICAvLyB0eXBpY2FsbHksIHdlIGdldCBPKDEpIGFjcm9zcyB0aGUgYm9hcmQgd2l0aCB0aGlzIGRhdGEgc3RydWN0dXJlXG4gICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKFVuaXZlcnNhbFNlYXJjaC5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFVuaXZlcnNhbFNlYXJjaCkpLmNhbGwodGhpcywgcHJvcHMpKTtcblxuICAgIF90aGlzLnN0YXRlID0ge1xuICAgICAgcXVlcnk6ICcnLFxuICAgICAgcmVzdWx0czogbmV3IFNldCgpXG4gICAgfTtcblxuICAgIF90aGlzLmNoZWNrRm9yQ2F0ZWdvcmllcyA9IF90aGlzLmNoZWNrRm9yQ2F0ZWdvcmllcy5iaW5kKF90aGlzKTtcbiAgICBfdGhpcy5pbnB1dFF1ZXJ5ID0gX3RoaXMuaW5wdXRRdWVyeS5iaW5kKF90aGlzKTtcbiAgICBfdGhpcy5maWx0ZXJNYXRjaGVzID0gX3RoaXMuZmlsdGVyTWF0Y2hlcy5iaW5kKF90aGlzKTtcbiAgICBfdGhpcy5yZW5kZXJNYXRjaGVzID0gX3RoaXMucmVuZGVyTWF0Y2hlcy5iaW5kKF90aGlzKTtcbiAgICBfdGhpcy5yZW5kZXJNYXRjaENvdW50ID0gX3RoaXMucmVuZGVyTWF0Y2hDb3VudC5iaW5kKF90aGlzKTtcblxuICAgIC8vIGNoZWNrIGlmIGNhdGVnb3JpZXMgd2VyZSBleHBsaWNpdGx5IHBhc3NlZFxuICAgIC8vIGlmIG5vdCwgaXRlcmF0ZSB0aHJvdWdoIHRoZSBPYmplY3Qga2V5c1xuICAgIC8vIGFuZCBzZWUgaWYgY2F0ZWdvcnkgaW5jbHVzaW9uIGNhbiBiZSBkZXRlY3RlZCBmcm9tIHN0cnVjdHVyZVxuICAgIF90aGlzLmluY2x1ZGVDYXRlZ29yaWVzID0gdHlwZW9mIF90aGlzLmluY2x1ZGVDYXRlZ29yaWVzICE9PSAndW5kZWZpbmVkJyA/IF90aGlzLnByb3BzLmhhc0NhdGVnb3JpZXMgOiBfdGhpcy5jaGVja0ZvckNhdGVnb3JpZXMocHJvcHMubGlzdFRvU2VhcmNoKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoVW5pdmVyc2FsU2VhcmNoLCBbe1xuICAgIGtleTogJ2NoZWNrRm9yQ2F0ZWdvcmllcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNoZWNrRm9yQ2F0ZWdvcmllcyhsaXN0VG9TZWFyY2gpIHtcbiAgICAgIHZhciBsaXN0S2V5cyA9IE9iamVjdC5rZXlzKGxpc3RUb1NlYXJjaCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3RLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGxpc3RUb1NlYXJjaFtsaXN0S2V5c1tpXV0pKSB7XG4gICAgICAgICAgLy8gc2hvcnQtY2lyY3VpdCBpZiBmb2xsb3dpbmcgdGhlIE9iamVjdCAtLT4gQXJyYXkgc3RydWN0dXJlXG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIGlmIG5vdCwgYXNzdW1lIHJlZ3VsYXIgYXJyYXlcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdpbnB1dFF1ZXJ5JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5wdXRRdWVyeShlKSB7XG4gICAgICAvLyBlc2NhcGUgaW5wdXQgYW5kIGJ1aWxkIFJFIHF1ZXJ5XG4gICAgICB2YXIgaW5wdXQgPSBlLnRhcmdldC52YWx1ZS5yZXBsYWNlKC9bXFwuXFwrXFwqXFw/XFxeXFwkXFxbXFxdXFx7XFx9XFwoXFwpXFx8XFwvXFxcXF0vaWcsIGZ1bmN0aW9uIChzeW0pIHtcbiAgICAgICAgcmV0dXJuICdcXFxcJyArIHN5bTtcbiAgICAgIH0pO1xuICAgICAgdmFyIHJlID0gaW5wdXQudHJpbSgpLmxlbmd0aCA+IDAgPyBuZXcgUmVnRXhwKGlucHV0LnRyaW0oKSwgJ2dpJykgOiAnJztcblxuICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIHF1ZXJ5OiBpbnB1dFxuICAgICAgfSk7XG5cbiAgICAgIGlmIChpbnB1dCkge1xuICAgICAgICAvLyB1c2Ugb3VyIFJFIG1hdGNoZXMgdG8gZmlsdGVyIG9uIG1hdGNoaW5nIHN0cmluZ3NcbiAgICAgICAgdGhpcy5maWx0ZXJNYXRjaGVzKHJlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGNsZWFyIGFsbCByZXN1bHRzIGlmIHNlYXJjaCBzdHJpbmcgaXMgZW1wdHlcbiAgICAgICAgdGhpcy5zdGF0ZS5yZXN1bHRzLmNsZWFyKCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZmlsdGVyTWF0Y2hlcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpbHRlck1hdGNoZXMocmUpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB2YXIgc2NhbiA9IGZ1bmN0aW9uIHNjYW4oaW5wdXRBcnIsIGNhdGVnb3J5KSB7XG4gICAgICAgIC8vIHdlIG5lZWQgdGhpcyBvZmZzZXQgdG8gc2VlIGlmIHdlJ3JlIGJlbG93IGEgbGltaXQgaWYgb25lIGlzIHNwZWNpZmllZFxuICAgICAgICAvLyBhbmQvb3IgdG8gc2VlIGlmIHRoZSBjYXRlZ29yeSBoZWFkZXIgbmVlZHMgdG8gbW92ZSBkb3duXG4gICAgICAgIHZhciBvZmZzZXQgPSAwO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlucHV0QXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGl0ZW0gPSBpbnB1dEFycltpXTtcbiAgICAgICAgICBpZiAoaXRlbS5uYW1lLm1hdGNoKHJlKSAmJiByZSAhPT0gJycpIHtcbiAgICAgICAgICAgIC8vIGlmIHN0cmluZyBtYXRjaGVzXG4gICAgICAgICAgICBpZiAob2Zmc2V0IC0gaSA9PT0gMCkge1xuICAgICAgICAgICAgICAvLyBpZiBmaXJzdCBtYXRjaCBpbiBuZXcgY2F0ZWdvcnksIGFkZCBfZmlyc3RJbkNhdGVnb3J5IHByb3BlcnR5XG4gICAgICAgICAgICAgIC8vIHRoaXMgd2lsbCBiZSB1c2VkIGFzIGEgZmxhZyB0byByZW5kZXIgdGhlIGNhdGVnb3J5IGhlYWRlciBiZWxvdy5cbiAgICAgICAgICAgICAgaXRlbS5fZmlyc3RJbkNhdGVnb3J5ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGl0ZW0uX2NhdGVnb3J5ID0gY2F0ZWdvcnk7XG4gICAgICAgICAgICBfdGhpczIuc3RhdGUucmVzdWx0cy5hZGQoaXRlbSk7XG5cbiAgICAgICAgICAgIC8vIGlmIGEgbGltaXQgd2FzIHBhc3NlZCBpbiwgY2hlY2sgaWYgd2UndmUgZXhjZWVkZWQgaXRcbiAgICAgICAgICAgIC8vIGlmIHNvLCBiYWlsIG91dFxuICAgICAgICAgICAgaWYgKF90aGlzMi5wcm9wcy5saW1pdFJlc3VsdHMgJiYgb2Zmc2V0IC0gaSArIDEgPiBfdGhpczIucHJvcHMubGltaXRSZXN1bHRzKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKF90aGlzMi5zdGF0ZS5yZXN1bHRzLmhhcyhpdGVtKSAmJiByZSAhPT0gJycpIHtcbiAgICAgICAgICAgIC8vIGlmIG5vIG1hdGNoLCBidXQgcHJlc2VudCBpbiBwcmV2aW91cyByZXN1bHQgc2V0LCBkZWxldGUgYW5kIGluY3JlbWVudFxuICAgICAgICAgICAgLy8gb2Zmc2V0XG4gICAgICAgICAgICBfdGhpczIuc3RhdGUucmVzdWx0cy5kZWxldGUoaXRlbSk7XG4gICAgICAgICAgICBvZmZzZXQrKztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gaWYgZm9yIGFueSByZWFzb24gYW4gZW1wdHkgaXRlbSBleGlzdHMsIGp1c3QgaW5jcmVtZW50IHRoZSBvZmZzZXRcbiAgICAgICAgICAgIG9mZnNldCsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgaWYgKHRoaXMuaW5jbHVkZUNhdGVnb3JpZXMpIHtcbiAgICAgICAgLy8gaWYgdGhlcmUgYXJlIGNhdGVnb3JpZXMsIGl0ZXJhdGUgdGhyb3VnaCB0aGUgY29udGVudHMgb2YgZWFjaCBvbmUgc2VwYXJhdGVseVxuICAgICAgICBPYmplY3Qua2V5cyh0aGlzLnByb3BzLmxpc3RUb1NlYXJjaCkuZm9yRWFjaChmdW5jdGlvbiAoY2F0ZWdvcnkpIHtcbiAgICAgICAgICBzY2FuKF90aGlzMi5wcm9wcy5saXN0VG9TZWFyY2hbY2F0ZWdvcnldLCBjYXRlZ29yeSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gb3RoZXJ3aXNlLCBzaW1wbHkgaXRlcmF0ZSB0aHJvdWdoIGEgc2luZ2xlIGFycmF5XG4gICAgICAgIHNjYW4odGhpcy5wcm9wcy5saXN0VG9TZWFyY2gpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3JlbmRlck1hdGNoZXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXJNYXRjaGVzKHJlc3VsdHNTZXQpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICAvLyB3ZSB1c2UgYSBTcHJlYWQgT3BlcmF0b3IgdG8gdGVtcG9yYXJpbHkgdHJhbnNmb3JtIGEgU2V0IGludG8gYW4gQXJyYXlcbiAgICAgIC8vIHRoaXMgbWFrZXMgaXQgZWFzaWVyIHRvIG1hcCBpbnRvIFJlYWN0XG4gICAgICByZXR1cm4gW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShyZXN1bHRzU2V0KSkubWFwKGZ1bmN0aW9uIChtYXRjaGluZ0VudHJ5LCBpKSB7XG4gICAgICAgIGlmIChfdGhpczMucHJvcHMuY3VzdG9tQ29tcG9uZW50KSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzMy5wcm9wcy5jdXN0b21Db21wb25lbnQobWF0Y2hpbmdFbnRyeSwgaSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZGVmYXVsdCBzdHJ1Y3R1cmUgaWYgbm90IHNwZWNpZmllZFxuICAgICAgICB2YXIgZW50cnkgPSBfcmVhY3QyLmRlZmF1bHQuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAnZGl2JyxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjbGFzc05hbWU6ICd1bml2LXNlYXJjaC1tYXRjaGluZy1yZXN1bHRzICcgKyAobWF0Y2hpbmdFbnRyeS5fZmlyc3RJbkNhdGVnb3J5ID8gJ3VuaXYtc2VhcmNoLWNhdGVnb3J5LWhlYWQnIDogJycpLFxuICAgICAgICAgICAga2V5OiAnbWF0Y2hfJyArIGlcbiAgICAgICAgICB9LFxuICAgICAgICAgIF90aGlzMy5pbmNsdWRlQ2F0ZWdvcmllcyAmJiBtYXRjaGluZ0VudHJ5Ll9maXJzdEluQ2F0ZWdvcnkgPyBfcmVhY3QyLmRlZmF1bHQuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICdkaXYnLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBjbGFzc05hbWU6ICd1bml2LXNlYXJjaC1jYXRlZ29yeS1oZWFkJyxcbiAgICAgICAgICAgICAgc3R5bGU6IHsgY29sb3I6ICcjYWFhJywgZm9udFN0eWxlOiAnaXRhbGljJywgZm9udFNpemU6ICcxMnB4JywgbWFyZ2luOiAnMTBweCAwJyB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbWF0Y2hpbmdFbnRyeS5fY2F0ZWdvcnlcbiAgICAgICAgICApIDogbnVsbCxcbiAgICAgICAgICBtYXRjaGluZ0VudHJ5Lm5hbWVcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIGVudHJ5O1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAncmVuZGVyTWF0Y2hDb3VudCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlck1hdGNoQ291bnQobWF0Y2hDb3VudCkge1xuICAgICAgLy8gb3B0aW9uYWxcbiAgICAgIHJldHVybiB0aGlzLnByb3BzLmN1c3RvbU1hdGNoQ291bnRDb21wb25lbnQgPyB0aGlzLnByb3BzLmN1c3RvbU1hdGNoQ291bnRDb21wb25lbnQobWF0Y2hDb3VudCkgOiBfcmVhY3QyLmRlZmF1bHQuY3JlYXRlRWxlbWVudChcbiAgICAgICAgJ2RpdicsXG4gICAgICAgIHsgY2xhc3NOYW1lOiAndW5pdi1zZWFyY2gtbWF0Y2gtY291bnQnLCBzdHlsZTogeyBtYXJnaW5Ub3A6ICcxMHB4JywgY29sb3I6ICcjYWFhJyB9IH0sXG4gICAgICAgIG1hdGNoQ291bnQsXG4gICAgICAgICcgTWF0Y2hlcydcbiAgICAgICk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAncmVuZGVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgdmFyIG5vTWF0Y2hNZXNzYWdlID0gX3JlYWN0Mi5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICdkaXYnLFxuICAgICAgICBudWxsLFxuICAgICAgICAnTm8gTWF0Y2hlcy4uLidcbiAgICAgICk7XG4gICAgICBpZiAoIXRoaXMuc3RhdGUucXVlcnkgfHwgdGhpcy5wcm9wcy5oaWRlTm9NYXRjaE1lc3NhZ2UpIHtcbiAgICAgICAgbm9NYXRjaE1lc3NhZ2UgPSBudWxsO1xuICAgICAgfVxuICAgICAgdmFyIG1hdGNoQ291bnRDb21wb25lbnQgPSB0aGlzLnByb3BzLnNob3dNYXRjaENvdW50ID8gdGhpcy5yZW5kZXJNYXRjaENvdW50KHRoaXMuc3RhdGUucmVzdWx0cy5zaXplKSA6IG51bGw7XG4gICAgICB2YXIgbWF0Y2hpbmdJdGVtRWxlbWVudHMgPSB0aGlzLnN0YXRlLnJlc3VsdHMuc2l6ZSA+IDAgPyB0aGlzLnJlbmRlck1hdGNoZXModGhpcy5zdGF0ZS5yZXN1bHRzKSA6IG5vTWF0Y2hNZXNzYWdlO1xuXG4gICAgICByZXR1cm4gX3JlYWN0Mi5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICdkaXYnLFxuICAgICAgICB7IGNsYXNzTmFtZTogJ3VuaXYtc2VhcmNoLXdyYXBwZXInIH0sXG4gICAgICAgIF9yZWFjdDIuZGVmYXVsdC5jcmVhdGVFbGVtZW50KCdpbnB1dCcsIHsgb25DaGFuZ2U6IHRoaXMuaW5wdXRRdWVyeSB9KSxcbiAgICAgICAgdGhpcy5wcm9wcy5wbGFjZWhvbGRlcixcbiAgICAgICAgdGhpcy5wcm9wcy5zaG93TWF0Y2hDb3VudCA/IG1hdGNoQ291bnRDb21wb25lbnQgOiBudWxsLFxuICAgICAgICBfcmVhY3QyLmRlZmF1bHQuY3JlYXRlRWxlbWVudCgnYnInLCBudWxsKSxcbiAgICAgICAgX3JlYWN0Mi5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoJ2JyJywgbnVsbCksXG4gICAgICAgIF9yZWFjdDIuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICdkaXYnLFxuICAgICAgICAgIHsgY2xhc3NOYW1lOiAndW5pdi1zZWFyY2gtcmVzdWx0cy13cmFwcGVyJyB9LFxuICAgICAgICAgIG1hdGNoaW5nSXRlbUVsZW1lbnRzXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFVuaXZlcnNhbFNlYXJjaDtcbn0oX3JlYWN0Mi5kZWZhdWx0LkNvbXBvbmVudCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFVuaXZlcnNhbFNlYXJjaDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9Vbml2ZXJzYWxTZWFyY2guanNcbi8vIG1vZHVsZSBpZCA9IDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///0\n")},function(module,exports){eval("module.exports = __WEBPACK_EXTERNAL_MODULE_1__;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9leHRlcm5hbCBcInJlYWN0XCI/M2M2MiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfMV9fO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwicmVhY3RcIlxuLy8gbW9kdWxlIGlkID0gMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1\n")}])});